0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。

 

示例 1：
```
输入: n = 5, m = 3
输出: 3
```
示例 2：
```
输入: n = 10, m = 17
输出: 2
```

限制：
```
1 <= n <= 10^5
1 <= m <= 10^6
```



### 问题分解

首先尝试着把问题规模减少.

```
还是以 f(5,3)举例, 0->1->2->3->4 第一轮删除2之后变成了 3->4->0->1
这里用链表代替圆圈, 链表的头部代表开始数的地方. 删完2之后从3开始数, 所以是3->4->0->1
现在变成了4个节点的链表删除第3个元素了, 只不过这个链表是从3开始的.
我们如果知道f(4,3)的值, 设f(4,3) = x, 也就是说 0->1->2->3 这个链表循环着删最后剩下x, 
那么只需要建立一个从(0,1,2,3)到(3,4,0,1)的映射
0 -> 3
1 -> 4
2 -> 0
3 -> 1
记这个映射为h,
那么因为0->1->2->3这个链表循环着删最后剩下x, 所以3->4->0->1这个链表循环着删最后剩下h(x)了
也即0->1->2->3->4这个链表循环着删最后剩下h(x)了. 问题就能递归的求解了.

下面就是寻找映射h了. 多写几组例子观察下发现h(x) = (x + m) % n  这里的n指的是上一层的n, 也就是n = 5

所以找到了规律 f(n.m) = (f(n-1,m) + m) % n
```

```java
class Solution {
    public int lastRemaining0(int n, int m) {
        if(n == 1){
            return 0;
        }
        else{
            return (lastRemaining(n-1, m) + m) % n;
        }
    }
    public int lastRemaining(int n, int m) {
        if(n == 1){
            return 0;
        }
        else{
            int res = 0;
            for(int i = 2; i <= n; ++i){
                res = (res + m) % i;
            }
            return res;
        }
    }
}
```

