数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。

请写一个函数，求任意第n位对应的数字。

 

示例 1：
```
输入：n = 3
输出：3
```
示例 2：
```
输入：n = 11
输出：0
```

限制：
```
0 <= n < 2^31
```



### 找规律



首先这里为了通用起见, 把开头的0去掉. 这样有

```python
1-9 一共9个数字, 每个数字1位, 共有 9 * 1 个字符                   # 第0类
10-99 一共90个数字, 每个数字2位, 共有 90 * 2 个字符               # 第1类
100-999 一共900个数字, 每个数字3位, 共有 900 * 3 个字符           # 第2类
...
10^i - (10^(i+1)-1) 一共 9*10^(i) 个数字, 每个数字i+1位, 共有 9*10^(i)*(i+1)个字符.  # 第i类
```



所以, 先通过找到对应的位置是第几类, 然后再确定对应的字符是几.



```c++
例如,n = 213,
首先计算,n > 9 * 1, 所以不是第0类, 把字符序列的"123456789"去掉之后变成寻找以"101112"开头的字符序列的第n-9个位置的字符. 更新n = n-9 = 204
然后, n = 204 > 90 * 2, 所以不是第1类, 把字符序列的"101112...9899"去掉之后变成寻找以"100101102"开头的字符序列的第n-180个位置的字符. 更新n = n-180 = 24.

然后, n = 24 < 900 * 3, 所以n在第2类中间, 即n所在的区间为3位数的区间.即从"100101102"开始之后的24个字符. 
下面要计算第24个字符在哪个数字里面.
rank = n / digit_count = 24 / 3 = 8; 
residual = n % digit_count = 24 % 3 = 0;
即第8个数的第0个字符. 第8个数为 std::pow(10,digit_count - 1) + rank = 10^2 + 8 = 108.
108的第0个字符显然为 number / (int) std::pow(10, digit_count - residual - 1) % 10 = (108/10^2)%10 = 1.
所以, "123456789"字符序列的第213个字符是'1'
即"0123456789"字符序列的第214个字符是'1'

```





```c++
class Solution {
public:
    int findNthDigit(int n) {      // 在0123456789101112131415字符序列的位置n的字符
        return n ? findNthDight0(n-1) : 0;
    }
private:
    int findNthDight0(int n){  // 在123456789101112131415字符序列的位置n的字符. 显然对于n > 0 有 findNthDigit(n) = findNthDigit0(n-1)
        int digit_count = 1;
        int base = 9;
        while(n >= (long) digit_count * base){
            n -= digit_count * base;
            ++digit_count;
            base *= 10;
        }
        int rank = n / digit_count;
        int residual = n % digit_count;
        int number = (int) std::pow(10,digit_count - 1) + rank;
        return number / (int) std::pow(10, digit_count - residual - 1) % 10;
    }
};
```

